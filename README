## Farcasanu Bianca Ioana 313CAb 2023-2024

    Pentru explicarea programului voi aborda fiecare functie in parte.

    Am inceput programul cu functia 'alocare_memorie_matrice' ce intoarce un
rezultat de tip int**, functie ce o folosesc pentru a aloca memorie unei
matrici de fiecare data cand am nevoie.

    Asemanator am creat functia 'free_matrice' ce elibereaza memoria alocata
dinamic pentru o matrice.

    Pentru prima cerinta a problemei am creat functia
'citire_si_inserare_matrice' ce pune valorile dimensiunilor matricii intr-un
vector de linii, respectiv un vector de coloane, ambii alocati dinamic, aloca
memorie pentru matricea ce urmeaza sa fie citita, citeste matricea, verifica
daca este suficient spatiul alocat pana atunci in vectorul de matrici, iar daca
nu este, realoca spatiu dubalndu-l, introduc matricea citita in vectorul de
matrici, cresc indexul k pentru contorizarea matricilor in vectorul de matrici
si, in final, realoc spatiu vectorilor pentru linii si coloane pentru
urmatoarele matrici.

    Functia 'afisare_matrice' afiseaza pe ecran matricea de la indexul 'index'
din vectorul de matrici sau mesajul aferent.

    Functia 'redimensionare' citeste, in primul rand, datele de intrare,
alocand dinamic memorie pentru vectorii ce stocheaza indecsii ce trebuie
combinati pentru crearea noii matrici. Pe prima ramura a if-ului, afisarea
mesajului implica si dealocarea memoriei pentru vectorii cititi, iar pe a doua
ramura a if-ului (in cazul in care matricea exista in vectorul de matrici) se
realizeaza propriu-zis redimensionarea matricii. Aloc dinamic memorie pentru
matricea pe care trebuie sa o redimensionez folosind prima functie creata, o
construiesc mai apoi luand toate combinatiile din vectorii cititi, eliberez
memoria matricii initiale din vector intrucat noua matrice are alte dimensiuni,
modific numarul liniilor si coloanelor in vectorii ce retin pentru fiecare
matrice, introduc matricea redimensionata in vectorul de matrici, dupa care
eliberez memoria pentru cei 2 vectori cititi intrucat nu mai am nevoie de ei.

    Functia 'inmultire_matrici', dupa cum sugereaza si numele, inmulteste 2
matrici. Citeste mai intai cei 2 indecsi ai matricilor pe care vrem sa le
inmultim, afiseaza mesajele aferente daca este cazul, dupa care iau cateva
variabile auxiliare pentru a usura notatiile. Aloc memorie pentru matricea
in care se va afla rezultatul, realizez inmultirea, transformand fiecare
termen intr-un numar de tip int (modulo 10007), iar apoi verific daca memoria
este destula, dubland spatiul in cazul in care nu este. Introduc atat matricea
rezultata la finalul vectorului de matrici, cat si dimensiunile sale in
vectorii liniilor si coloanelor, dupa ce am realocat spatiu. Cresc indexul k,
k devenind indexul urmatoarei matrici ce va fi introdusa in vectorul de
matrici.

    Functia 'suma_elem_matrice' realizeaza suma tuturor elementelor unei
matrici pentru a o folosi in sortarea matricilor. Transforma, de asemenea,
rezultatul intr-un numar de tip int prin modulo 10007, de aceea returneaza o
valoarea de tip int.

    Functia 'sortare_matrici' are ca idee de baza principiul sortarii numerelor
intr-un vector simplu, dar de aceasta data, in loc sa interschimbe numerele
intre ele, interschimba matricile din vectorul de matrici. Folosesc functia
suma_elem_matrice. Nu am nevoie de nicio matrice auxiliara sau de o alocare
dinamica intrucat fiecare matrice are spatiul sau alocat, schimbandu-se doar
matricea catre care pointeaza fiecare index din vectorul de matrici.

    Functia 'transpusa' ori afiseaza mesajul aferent, ori transpune matricea
de la indexul 'index'. Aloc memorie pentru noua matrice transpusa ce va avea
numarul liniilor egal cu numarul coloanelor matricei pe care vrem s-o
transpunem si numarul coloanelor egal cu numarul liniilor matricei pe care
vrem s-o transpunem. Construiesc matricea, parcurgand pe coloane matricea
initiala, luand in mod interschimbat i si j, si plasez fiecare element in noua
matrice. Modific, deopotriva, dimensiunile din vectorii de linii si coloane,
eliberez memoria matricii vechi cu ajutorul functiei create si o introduc
apoi pe cea transpusa(are deja memorie alocata pentru ea).

    Functia 'inmultire_matrice_pentru_ridicare_putere' am creat-o pentru a
inmulti 2 matrici patratice si pentru a o folosi in ridicarea la putere in
timp logaritmic. Nu am putut folosi functia anterioara 'inmultire_matrici'
intrucat nu aveam nevoie sa imi insereze matricea creata la finalul
vectorului de matrici, ci aveam nevoia ca memoria alocata matricii rezultate
sa fie eliberata pentru a nu avea scapari de memorie. Am utilizat acelasi
principiu de inmultire, numai ca acum rezultatul va fi intors intr-una dintre
matricile date ca parametru. Am alocat memorie pentru o matrice auxiliara in
care se va afla rezultatul inmultirii, am creat-o, am inlocuit in matricea
data ca parametru noile valori, dupa care am eliberat memoria.

    Functia 'ridicare_la_putere' realizeaza ridicarea la putere a unei matrici
patratice in timp logaritmic. Dupa ce citeste indexul si puterea la care
trebuie ridicata matricea, verifica daca trebuie afisat un anumit mesaj, iar
daca nu trebuie, incepe algoritmul de ridicare la putere in timp logaritmic.
Initializez matricea cu elementul neutru fata de inmultirea matricilor (In),
astfel acoperind cazul in care puterea este 0. Cat timp puterea este diferita
de 0, verific daca puterea este impara si inmultesc matricea rezultat cu 
matricea mea, intorcand rezultatul in matricea rezultat. În caz contrar,
matricea inițială este doar ridicată la pătrat, fara a mai face primul if.
Ridicarea la patrat a matricii se face indiferent de paritatea puterii.
Acest proces continuă până când puterea devine 0, la fiecare pas puterea
impartindu-se la 2. Intr-un final, puterea va deveni oricum 1 si va realiza
ceea ce se afla in if, acela fiind si rezultatul stocat in matricea rezultat.
Va face si ridicarea la patrat a matricii, insa puterea va deveni 0 si nu va
mai intra in acel while. La final, eliberez memoria matricei vechi si o
introduc pe cea rezultat.

    Functia 'eliminare_matrice' elibereaza memoria pentru matricea pe care vrem
sa o eliminam, muta fiecare matrice cu index mai in spate, scad indexul de
contorizare a numarului de matrici din vectorul de matrici si verific daca se
poate elibera o parte din memoria alocata in vector in cazul eliminarii mai
multor matrici. Daca se poate, adica daca numarul matricilor din vector a ajuns
la jumatate fata de memoria alocata, se injumatateste atat spatiul vectorului
de matrici, cat si spatiul vectorilor pentru linii si coloane.

    Functiile 'adunare_matrici' si 'scadere_matrici' sunt folosite in
aglortimul lui Strassen de inmultire pentru calcularea celor 7 matrici.
Acestea aduna, respectiv scad 2 matrici cu acelasi numar de elemente,
intorcand rezultatul in matricea 'c'.

    Functiile 'alocare_mem_matrici_strassen' si 'eliberare_matrici_strassen'
sunt utilizate pentru a aloca memorie tuturor matricilor folosite in
algoritmul lui Strassen.

    Functia 'strassen' implementeaza agloritmul lui Strassen de inmultire a
matricilor. Pentru inceput, aloc memorie pentru toate submatricile de care
am nevoie. Avand 2 matrici pe care trebuie sa le inmultesc, le impart pe
fiecare in 4 submatrici blocuri (fiind matrici patratice ce au ca dimensiune
o putere a lui 2, toate vor avea dimensiunea egala cu n / 2). Mai apoi calculez
toate cele 7 submatrici (p1 -> p7), iar fiecare la randul ei este calculata
prin recursivitate tot cu algoritmul lui Strassen,  utilizand si functiile de
adunare si scadere a matricilor. Matricea 'c' va fi cea care va contine
rezultatul, fiind si aceasta impartita in 4 submatrici blocuri care vor fi
calculate cu ajutorul celor 7 submatrici auxiliare (p1 -> p7). Intr-un final
aloc memorie pentru matricea rezultata si o contruiesc din cele 4 submatrici
ale sale. Dealoc toata memoria alocata dinamic pentru matricile pe care le-am
utilizat.
Voi arata explicit ce calculez in functiile din 'strassen' si cum ajung
sa creez cele 7 submatrici de la p1 la p7:

    // calculez submatricile p1 -> p7
    adunare_matrici(newsize, a11, a22, &temp1); // a11 + a22
    adunare_matrici(newsize, b11, b22, &temp2); // b11 + b22
    strassen(newsize, temp1, temp2, &p1); // p1 = (a11 + a22) * (b11 + b22)

    adunare_matrici(newsize, a21, a22, &temp1); // a21 + a22
    strassen(newsize, temp1, b11, &p2); // p2 = (a21 + a22) * b11

    scadere_matrici(newsize, b12, b22, &temp1); // b12 - b22
    strassen(newsize, a11, temp1, &p3); // p3 = a11 * (b12 - b22)

    scadere_matrici(newsize, b21, b11, &temp1); // b21 - b11
    strassen(newsize, a22, temp1, &p4); // p4 = a22 * (b21 - b11)

    adunare_matrici(newsize, a11, a12, &temp1); // a11 + a12
    strassen(newsize, temp1, b22, &p5); // p5 = (a11 + a12) * b22

    scadere_matrici(newsize, a21, a11, &temp1); // a21 - a11
    adunare_matrici(newsize, b11, b12, &temp2); // b11 + b12
    strassen(newsize, temp1, temp2, &p6); // p6 = (a21 - a11) * (b11 + b12)

    scadere_matrici(newsize, a12, a22, &temp1); // a12 - a22
    adunare_matrici(newsize, b21, b22, &temp2); // b21 + b22
    strassen(newsize, temp1, temp2, &p7); // p7 = (a12 - a22) * (a21 + a22)

    // calculez submatricile lui c
    adunare_matrici(newsize, p1, p4, &temp1); // p1 + p4
    scadere_matrici(newsize, temp1, p5, &temp2); // (p1 + p4) - p5
    adunare_matrici(newsize, temp2, p7, &c11); // c11 = p1 + p4 - p5 + p7

    adunare_matrici(newsize, p3, p5, &c12); // c12 = p3 + p5

    adunare_matrici(newsize, p2, p4, &c21); // c21 = p2 + p4

    adunare_matrici(newsize, p1, p3, &temp1); // p1 + p3
    scadere_matrici(newsize, temp1, p2, &temp2); // (p1 + p3) - p2
    adunare_matrici(newsize, temp2, p6, &c22); // c22 = p1 + p3 - p2 + p6

    Functia 'inserare_matrice_in_vector' am creat-o pentru a adauga la
finalul vectorului de matrici matricea rezultat din algoritmul lui Strassen,
incluzand si verificarea nevoii de dublare a spatiului alocat atat pentru
vectorul de matrici, cat si pentru vectorii liniilor si coloanelor. Nu o
puteam include in interiorul functiei 'strassen' intrucat, fiind o functie
recursiva, ar fi adaugat o matrice la fiecare apel al functiei.

    Ultima functie 'eliberare_finala' este apelata cand se citeste litera 'Q'
si elibereaza memoria pentru vectorul de matrici si vectorii liniilor si
coloanelor.
